/*** Definition Section ***/
%{
#include "analyzer.h"
bool error_lexical=false; 
unsigned int lineno=1;
char * send_error(char *error ,int line);
%}

%option stack
%option noyywrap
%option yylineno
/*%option debug*/

separateur [ \t\n\r]+
blanc [ \t]+
lettre [a-zA-Z]
chiffre [0-9]
nombre {chiffre}+
signe [-+]
entier {signe}?{nombre}
reel {entier}"."{nombre}
string1 \"[^\"]*\"
string2 \'[^\']*\'
string {string1}|{string2}
cst {entier}|{reel}|{string}
identificateur {lettre}({lettre}|{nombre})*

/*** state Section ***/

%x comment
%x inlin_comm
%x string

%s boolean
%s block
%s if_block
%s if_else
%s for_block
%s while_block
%s matching
%s case_block


/****************************************** Rule Section ******************************************/
%%

 /****************************************** Strings ******************************************/
\"				 		{yy_push_state(string); yymore();}
<string>[^\"]*\" 		{ yy_pop_state(); yylval.texte = yytext; if(yy_top_state() == if_else || yy_top_state() == while_block ){ return TOK_STR; }else{return TOK_VARB;} }


 /****************************************** block_fonctions ******************************************/
 
(?i:"inicio")/{separateur}+ { return TOK_FINI ; }
(?i:"finito")/{separateur}+ { return TOK_FINF ; }

 /****************************************** types ******************************************/

(?i:"global"|"sarta"|"carta"|"entero"|"float"|"etiqueta"|"tablero"|"estrectura") {return TOK_TYPE ; }
 
 /****************************************** conditions ******************************************/

(?i:"si")							{yy_push_state(if_block); yy_push_state(boolean); return TOK_SI ; }
<boolean>(?i:"ento") 				{yy_pop_state(); return TOK_ALORS ; }
<if_block>(?i:"contrario")  		{return TOK_SINON ;}
<if_block,if_else>(?i:"finitosi")	{yy_pop_state(); return TOK_FINSI ; }

(?i:"cambiar")        					  {yy_push_state(matching); return TOK_CAMBIAR ;}
<matching>(?i:"caso"|"defecto") 		  {yy_push_state(case_block); return TOK_CASE ;}
<matching,case_block>(?i:"finitocambiar") {yy_pop_state(); return TOK_FINB ;}

 /****************************************** boucles ******************************************/

(?i:"por")							{ yy_push_state(for_block); return TOK_FOR ;}
<for_block>(?i:"en") 			 	{return TOK_DANS ;}
<for_block>(?i:"darse") 		 	{return TOK_FAIRE ;}
<for_block>(?i:"finitopor") 		{yy_pop_state(); return TOK_FINFOR ;}

(?i:"tanto") 						{yy_push_state(while_block); yy_push_state(boolean); return TOK_TANT ;}
<boolean>(?i:"darse")       		{return TOK_FAIRE ;}
<while_block>(?i:"finitotanto") 	{yy_pop_state(); return TOK_FINT ;}

 /****************************************** E/S ******************************************/

(?i:"leer")/{blanc}*"("{blanc}*{identificateur}    {return TOK_LEER ;}
(?i:"escrir")/{blanc}*"("{blanc}*{identificateur}  {return TOK_ESCRIR ;}

 /****************************************** operateurs arithmetiques ******************************************/

("+")/({blanc}*({identificateur}|{cst})) 		{return TOK_PLUS ; }
("-")/({blanc}*({identificateur}|{cst})) 		{return TOK_MOINS ;}
("*")/({blanc}*({identificateur}|{cst})) 		{return TOK_MUL ;}
("/")/({blanc}*({identificateur}|{cst})) 		{return TOK_DIV ;}
(?i:"mod")/({blanc}*({identificateur}|{cst})) 	{return TOK_MOD ;}
("^")/({blanc}*({identificateur}|{cst})) 		{return TOK_PUISS ;}

 /****************************************** operateurs logiques ******************************************/

(?i:"NAY") 	{if(yy_top_state() != if_else && yy_top_state() != while_block){yy_push_state(boolean);} return TOK_NON ;}
(?i:"AND") 	{return TOK_ET ;}
(?i:"OR") 	{return TOK_OU ;}

 /****************************************** operateurs logiques ******************************************/
 
"<-" {return TOK_AFFECT ;}

 /****************************************** operateurs comparaison ******************************************/

(?i:"eq")/{blanc}+ {return TOK_EQ ;}
(?i:"nq")/{blanc}+ {return TOK_NQ ;}
(?i:"lt")/{blanc}+ {return TOK_LT ;}
(?i:"gt")/{blanc}+ {return TOK_GT ;}
(?i:"le")/{blanc}+ {return TOK_LE ;}
(?i:"ge")/{blanc}+ {return TOK_GE ;}

 /****************************************** operateurs decalage ******************************************/

(?i:"DD"|"DG")/{blanc}{nombre}  {return TOK_DECAL ;}

 /****************************************** constants ******************************************/

{entier} {yylval.texte = yytext; 
			if(YYSTATE == boolean){ return TOK_VARB; }else{return TOK_NOMBRE;}
		 }

 /****************************************** ponctuation ******************************************/	
 /*{reel} {yylval.decimal=atof(yytext);	return TOK_NOMBRE;}*/

"(" 	{return TOK_PARG ;}
")" 	{return TOK_PARD ;}

"{" 	{return TOK_ACCOLG ;}
"[" 	{return TOK_BRACKG ;}
"<" 	{return TOK_OUVR ;}

"}" 	{return TOK_ACCOLD ;}
"]" 	{return TOK_BRACKD ;}
">" 	{return TOK_FERM ;}

"," 	{return TOK_VIRG ;}
"|" 	{return TOK_PIPE ;}
":" 	{return TOK_DPTS ;}

";" 	{if(YY_START == boolean){ yy_pop_state(); } return TOK_FINSTR ;}

 /****************************************** identificateurs ******************************************/

{identificateur} {	yylval.texte = yytext; 
					
					return (YY_START == boolean?TOK_VARB:TOK_VAR) ;
				}
	/*
	printf(" state = %d",YY_START == boolean);
	if(YY_START == boolean){ return TOK_VAR; }else{return TOK_VARB;}
{identificateur}/{blanc}*(?i:"eq"|"nq"|"lt"|"gt"|"le"|"ge"|"et"|"ou") {yy_push_state(boolean); yylval.texte = yytext; return TOK_VARB ;}
	*/



 /****************************************** commentaires ******************************************/

"**" 						{yy_push_state(comment);}
<comment>[^"**"]*("**") 	{yy_pop_state(); }
<comment>[^"**"]*[^"**"] 	{send_error(yytext,yylineno);}
!!							{yy_push_state(inlin_comm);}
<inlin_comm>.*				{yy_pop_state(); }

 /****************************************** blanks ******************************************/
"\n"            {lineno++;}
{separateur}	;



 /****************************************** other caracters ******************************************/
 
. 	{send_error(yytext,yylineno);}

 /****************************************** EOF ******************************************/

<<EOF>>  { return 0; }

%%

/****************************************** Code Section ******************************************/

char * send_error(char *error ,int line){
	error_lexical=true ;
	return error ;
}

